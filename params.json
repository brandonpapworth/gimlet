{"name":"Gimlet Cocktail","tagline":"A micro web application framework for OpenResty written in Moonscript inspired by Martini & Sinatra.","body":"#Gimlet Cocktail\r\nversion **0.1.0**\r\n\r\nGimlet Cocktail is a micro web application framework for [OpenResty](http://openresty.org/)[[2](#getting-started-note-2)] written in [Moonscript](http://moonscript.org/). The hope is that it's useful, modular, and makes writing web applications (especially RESTful ones) quick and fun.\r\n\r\n##Getting started\r\n\r\n* First thing to do is to install Moonscript [[1](#getting-started-note-1)]\r\n* To use the command line tool, you'll need a couple more dependencies:\r\n  * lua_cliargs >= 2.1 - For command line argument parsing.\r\n  * luafilesystem >= 1.5 - For ensuring the web server is running from the correct location.\r\n* Then you should make sure to either have OpenResty installed\r\n* (Alternatively) Install wsapi, wsapi-xavante, & xavante.\r\n\r\n* Create a file named app.moon with the following code:\r\n```moonscript\r\nimport get, run from require 'gimlet.classic'\r\n\r\nget '/', ->\r\n  'Hello world!'\r\n\r\nrun!\r\n```\r\n* Now you can compile the code with ```moonc app.moon```\r\n* You can run use the gimlet command to start the server ```gimlet app``` [[2](#getting-started-note-2)]\r\n\r\nYou will now have a Gimlet application running on your web server of choice on ```http://localhost:8080```\r\n\r\n[<a name=\"getting-started-note-1\">1</a>] All dependencies can be installed via LuaRocks.\r\n\r\n[<a name=\"getting-started-note-2\">2</a>] The default is use use OpenResty. [Xavante](http://keplerproject.github.io/xavante) can be used by using ```gimlet -x app```\r\n\r\n##Table of Contents\r\n* [Classic Gimlet](#classic-gimlet)\r\n  * [Handlers](#handlers)\r\n  * [Routing](#routing)\r\n  * [Services](#services)\r\n  * [Serving Static Files](#serving-static-files)\r\n* [Middleware Handlers](#middleware-handlers)\r\n  * [Middleware Yielding](#middleware-yielding)\r\n* [Available Middleware](#available-middleware)\r\n* [Code Reloading](#code-reloading)\r\n* [Using Lua](#using-lua)\r\n\r\n##Classic Gimlet\r\n ```gimlet.classic``` tries to provide reasonable defaults for most web applications. The general pieces are requiring ```gimlet.classic```, setting up any additional middleware, adding items to be passed to the routes, setting up your routing information, and running the application.\r\n```moonscript\r\n-- Pull in the Classic Gimlet\r\nclassic = require 'gimlet.classic'\r\n\r\n-- Optionally define a variable to be available to all requests\r\nclassic.map \"world\", 'World'\r\n\r\n-- Define a middleware to use\r\nclassic.use (require 'gimlet.render').Render!\r\n\r\n-- Define a route '/' with params\r\nclassic.get '/', (params) ->\r\n  params.render.json hello: params.world\r\n\r\n-- Run the Gimlet application\r\nclassic.run!\r\n```\r\n\r\n###Handlers\r\nHandlers are how you get things done in Gimlet (as they are in Martini.) A handler is a any callable function.\r\n```moonscript\r\nclassic.get '/', ->\r\n  print \"hello world\"\r\n```\r\n\r\n####Return Values\r\nHandlers can return a string value and that will be sent back as a simple HTTP HTML response.\r\n```moonscript\r\nclassic.get '/', ->\r\n  \"hello world\" -- HTTP 200 : \"hello world\"\r\n```\r\nIf the first option is numeric, it changes the HTTP response code.\r\n```moonscript\r\nclassic.get '/', ->\r\n  418, \"i'm a teapot\" -- HTTP 418 : \"i'm a teapot\"\r\n```\r\n\r\nIf the first option is a table, other things about the HTTP response can be changed, such as Content-Type, headers, and the status.\r\n```moonscript\r\nclassic.get '/', ->\r\n  'Content-Type': 'application/json', status: 401, [[{\"error\": \"you're not authorized to access content\"}]]\r\n```\r\n\r\n####Parameters\r\nThe handlers can optionally take a single table parameter.\r\n```moonscript\r\nclassic.get '/', (p) ->\r\n  p.utils.now!\r\n```\r\nThe following are mapped to the table by default:\r\n* gimlet - An instance of the Gimlet class\r\n* request - An instance of the HTTP request object\r\n* response - An instance of the HTTP response object.\r\n* utils - An instance of some utility functions\r\n\r\nIn addition to these, route globs and named parameters are mapped to the parameter as well. See [Routing](#routing) for more information on this.\r\n\r\n###Routing\r\nIn Gimlet, a route is an HTTP method paired with a URL-matching pattern. Each route can take one or more handler methods:\r\n```moonscript\r\nclassic.get '/', ->\r\n  -- show something\r\n\r\nclassic.patch '/', ->\r\n  -- update something\r\n\r\nclassic.post '/', ->\r\n  -- create something\r\n\r\nclassic.put '/', ->\r\n  -- replace something\r\n\r\nclassic.delete '/', ->\r\n  -- destroy something\r\n\r\nclassic.options '/', ->\r\n  -- http options\r\n\r\nclassic.not_found ->\r\n  -- handle 404\r\n```\r\n\r\nRoutes are matched in the order they are defined. The first route that matches the request is invoked.\r\n\r\nRoute patterns may include named parameters:\r\n```moonscript\r\nclassic.get '/:name', (p) ->\r\n  'hello ' .. p.params.name\r\n```\r\n\r\nRoutes can be matched with globs:\r\n```moonscript\r\nclassic.get '/**', (p) ->\r\n  'hello ' .. p.params[1]\r\n```\r\nRoute groups can be added too using the group method:\r\n```moonscript\r\nclassic.group '/books', (r) ->\r\n  r\\get '', get_books\r\n  r\\get '/:id', get_book\r\n  r\\post '/new', new_book\r\n  r\\put '/update/:id', update_book\r\n  r\\delete '/delete/:id', delete_book\r\n```\r\n###Services\r\nServices are objects that are available to be injected into a handler's parameters table.\r\n\r\n```moonscript\r\ndb = my_database!\r\nclassic.map \"db\", db -- the service will be available to all handlers as -> (p) p.db\r\n-- ...\r\nclassic.run!\r\n```\r\n\r\n###Serving Static Files\r\n```gimlet.classic``` automatically serves files from ```public``` relative to the main module.\r\n\r\nAlternatively, you can let the HTTP server handle static files with ```gimlet -s static_dir app```\r\n\r\n##Middleware Handlers\r\nMiddlware handlers sit between the incoming http request and the router. They are, in essence, no different than any other handler in Gimlet. You can add a middleware handler to the stack with:\r\n```moonscript\r\nclassic.use ->\r\n  -- do middleware stuff\r\n```\r\n\r\nYou also have full control over the middleware stack with the ```Gimlet\\handlers``` function. This will replace all handlers that were previously set:\r\n```moonscript\r\nclassic.handlers middleware1, middleware2, middleware3\r\n```\r\n\r\nMiddleware handlers tend to work well for things like: logging, authorization, authentication, sessions, errors, or anything else that needs to happen before and/or after an HTTP request.\r\n\r\n###Middleware Yielding\r\nDuring a middleware handler call, the middleware can optionally call ```coroutine.yield```. This allows somet things to happen before and after the request.\r\n```moonscript\r\nclassic.use ->\r\n  print \"before a request\"\r\n\r\n  coroutine.yield!\r\n\r\n  print \"after a request\"\r\n```\r\n\r\n##Available Middleware\r\n* [Render](http://github.com/losinggeneration/gimlet-render) - Handles rendering JSON & HTML templates.\r\n\r\n##Code Reloading\r\nCode reloading is accomplished by using ```gimlet -r``` It works well with OpenResty. However, Xavante seems to have some issues currently.\r\n\r\n##Using Lua\r\nUp until this point, Moonscript has been assumed for everything. There's support for using Lua; however, this isn't well tested.\r\n```lua\r\nlocal classic = require 'gimlet.classic'\r\n\r\nclassic.get('/', function()\r\n        return 'Hello world!'\r\nend)\r\n\r\nclassic.run()\r\n```\r\n\r\n##About\r\nGimlet Cocktail is inspired by projcets like [Martini](http://github.com/go-martini/martini) and [Sinatra](https://github.com/sinatra/sinatra). Some code is heavily based off Martini as well.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}